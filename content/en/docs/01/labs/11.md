---
title: "1.1 Tasks: Setup"
weight: 1
onlyWhenNot: baloise

sectionnumber: 1
---

## Task {{% param sectionnumber %}}.1: Deploy example application TODO: needs to be fixed, taken from current 1.2 lab

Create a namespace where the example application can be deployed to.

```bash
{{% param cliToolName %}} create namespace application-metrics
```

Deploy the Acend example Python application, which provides application metrics at `/metrics`:

```bash
{{% param cliToolName %}} -n application-metrics create deployment example-web-python \
--image=quay.io/acend/example-web-python
```

Use the following command to verify the deployment, that the pod `example-web-python` is Ready and Running. (use CTRL C to exit the command)

```bash
{{% param cliToolName %}} -n application-metrics get pod -w
```

We also need to create a Service for the new application. Create a file with the name `~/work/service.yaml` with the following content:

{{< readfile file="/content/en/docs/01/labs/service.yaml" code="true" lang="yaml" >}}

Create the Service with the following command:

```bash
{{% param cliToolName %}} apply -f ~/work/service.yaml -n application-metrics
```

This created a so-called [Kubernetes Service](https://kubernetes.io/docs/concepts/services-networking/service/)

```bash
{{% param cliToolName %}} -n application-metrics get services
```

Which gives you an output similar to this:

```bash
NAME                 TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
example-web-python   NodePort   10.101.249.125   <none>        5000:31626/TCP   2m9s
```

## Task {{% param sectionnumber %}}.2: Create a ServiceMonitor TODO: needs to be fixed, taken from current 1.2/1.3 lab

```bash
curl http://localhost:9100/metrics
```
Should result in something like:

```promql
# HELP python_gc_objects_collected_total Objects collected during gc
# TYPE python_gc_objects_collected_total counter
python_gc_objects_collected_total{generation="0"} 541.0
python_gc_objects_collected_total{generation="1"} 344.0
python_gc_objects_collected_total{generation="2"} 15.0
...
```

Since our newly deployed application now exposes metrics, the next thing we need to do, is to tell our Prometheus server to scrape metrics from the Kubernetes deployment. In a highly dynamic environment like Kubernetes this is done with so called Service Discovery.

**Task description**:

Create a ServiceMonitor for the example application

* Create a ServiceMonitor, which will configure Prometheus to scrape metrics from the example-web-python application every 30 seconds.
  * hint: `{{% param cliToolName %}} -n application-metrics apply -f my_file.yaml` will create a resource in the Kubernetes namespace

For this to work, you need to ensure:

* The example-web-python Service is labeled correctly and matches the labels you've defined in your ServiceMonitor.
* The port name in your ServiceMonitor configuration matches the port name in the Service definition.
  * hint: check with `{{% param cliToolName %}} -n application-metrics get service example-web-python -o yaml`
* Verify the target in the Prometheus user interface.

{{% details title="Hints" mode-switcher="normalexpertmode" %}}

Create the following ServiceMonitor (`~/work/servicemonitor.yaml`) in the `application-metrics` namespace

{{< readfile file="/content/en/docs/01/labs/servicemonitor.yaml" code="true" lang="yaml" >}}

Apply it using the following command:

```bash
{{% param cliToolName %}} -n application-metrics apply -f ~/work/servicemonitor.yaml
```

Verify that the target gets scraped in the [Prometheus user interface](http://{{% param replacePlaceholder.k8sPrometheus %}}/targets). Target name: `serviceMonitor/application-metrics/example-web-python-monitor/0` (it may take up to a minute for Prometheus to load the new configuration and scrape the metrics).

{{% /details %}}

